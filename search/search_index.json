{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Free-threaded CPython is coming!  </p> <p>After the acceptance by the Python Steering Council of, and the gradual rollout strategy for, PEP 703 - Making the Global Interpreter Lock Optional in CPython, a lot of work is happening both in CPython itself and across the Python ecosystem.</p> <p>This website aims to serve as a centralized resource both for Python package maintainers and end users interested in supporting or experimenting with free-threaded Python. An overview of the compatibility status of various Python libraries is maintained in:</p> <ul> <li>Compatibility status tracking</li> </ul> <p>This website also provide documentation and porting guidance - with a focus on extension modules using the Python C API, because that's where most of the work will be. The following resources should get you started:</p> <ul> <li>Installing free-threaded CPython</li> <li>Running Python with the GIL disabled</li> <li>Porting extension modules to support free-threading</li> <li>Setting up CI</li> <li>Finding, testing and debugging concurrency issues</li> </ul>"},{"location":"#about-this-site","title":"About this site","text":"<p>Any contributions are very much welcome - please open issues or pull requests on this repo for anything that seems in scope for this site or for tracking issues related to support for free-threaded Python across the ecosystem.</p> <p>This site is maintained primarily by Quansight Labs, where a team is working together with the Python runtime team at Meta and stakeholders across the ecosystem to jumpstart work on converting the libraries that make up the scientific Python and AI/ML stacks to work with the free-threaded build of CPython 3.13. Additionally, that effort will look at libraries like PyO3 that are needed to interface with CPython from other languages.</p>"},{"location":"ci/","title":"Setting up CI","text":"<p>Currently the <code>setup-python</code> GitHub Action does not support installing a free-threaded build. For now, here are some relatively easy ways:</p>"},{"location":"ci/#ubuntu-linux-ci-setup-via-deadsnakes-action","title":"Ubuntu Linux CI setup via <code>deadsnakes-action</code>","text":"<p>The easiest way to get a free-threaded Python build on a CI runner is with the <code>deadsnakes</code> Ubuntu PPA and the <code>deadsnakes-action</code> GitHub Action:</p> <pre><code>jobs:\n  free-threaded:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@...\n      - uses: deadsnakes/action@...\n        with:\n          python-version: 3.13-dev\n          nogil: true\n</code></pre> <p>You should replace the ellipses with versions for the actions. If there is a newer CPython 3.13 release available since this document was written or updated, use that version instead.</p>"},{"location":"ci/#windows-ci-setup-via-custom-powershell","title":"Windows CI setup via custom PowerShell","text":"<p>For installing a free-threaded build of Python on a Windows CI runner (<code>runs-on: windows-latest</code>), you can download and install directly from https://www.python.org/ftp/python/ as shown in the following PowerShell snippet (noting that the free-threaded binary is named <code>python{version}t.exe</code>, where the \"t\" is for free-\"t\"hreaded). For more tips see the docs on silent installation and options on Windows.</p> <pre><code>jobs:\n  free-threaded:\n    runs-on: windows-latest\n    steps:\n      - uses: actions/checkout@...\n      - name: custom python install script\n        shell: pwsh\n        run: |\n          $pythonInstallerUrl = \"https://www.python.org/ftp/python/3.13.0/python-3.13.0rc2-amd64.exe\"\n          Invoke-WebRequest $pythonInstallerUrl -OutFile setup-python.exe\n          Start-Process \"setup-python.exe\" -argumentlist \"/quiet PrependPath=1 TargetDir=C:\\Python313 Include_freethreaded=1\" -wait\n          C:\\Python313\\python3.13t.exe -m pip install -r requirements.txt\n          C:\\Python313\\python3.13t.exe -c \"import sys; print(sys._is_gil_enabled())\"\n</code></pre>"},{"location":"ci/#building-free-threaded-wheels-with-cibuildwheel","title":"Building free-threaded wheels with cibuildwheel","text":"<p>cibuildwheel has support for building free-threaded wheels on all platforms. If your project releases nightly wheels, we suggest configuring <code>cibuildwheel</code> to build nightly free-threaded wheels.</p> <p>If your project depends on Cython or the NumPy C API, you will need to install a Cython nightly wheel in the build, as the newest stable release of Cython cannot generate code that will compile under the free-threaded build. Cython 3.1.0 and NumPy 2.1.0 will be or are the first stable releases to support free-threaded python. See the project tracker for more detailed information about projects you may depend on.</p> <p>You can install nightly wheels for both Cython and NumPy using the following install command:</p> <pre><code>pip install -i https://pypi.anaconda.org/scientific-python-nightly-wheels/simple cython numpy\n</code></pre> <p>To ensure wheels are built correctly under cibuildwheel, you will need to specify the following variables in the environment for the cibuildwheel action:</p> <pre><code>  - name: Build wheels\n    uses: pypa/cibuildwheel@...\n    env:\n      CIBW_PRERELEASE_PYTHONS: true\n      CIBW_FREE_THREADED_SUPPORT: true\n      CIBW_BUILD: cp313t-${{ matrix.buildplat }}\n      # TODO:\n      # remove when a released cython can build free-threaded extensions\n      CIBW_BUILD_FRONTEND: 'pip; args: --no-build-isolation'\n</code></pre> <p>As above, replace the ellipses with a <code>cibuildwheel</code> version.</p> <p>If for some reason disabling build isolation is unworkable, you can also tell pip about the nightly wheel index and it will use it in an isolated build. To do this, set:</p> <pre><code>CIBW_BUILD_FRONTEND: 'pip; args: --pre --extra-index-url \"https://pypi.anaconda.org/scientific-python-nightly-wheels/simple\"'\n</code></pre> <p>Many projects use <code>build</code> instead of <code>pip</code> for the build frontend. See the cibuildwheel docs for more information about how to pass arguments to <code>build</code> and <code>pip</code>. See this comment on the <code>build</code> issue tracker if you need to use <code>build</code> and cannot disable build isolation.</p> <p>Note that nightly wheels may not be available on all platforms yet. Windows wheels, in particular, are not currently available for NumPy or projects that depend on NumPy (e.g., SciPy).</p> <p>You will also likely need to manually pass <code>-Xgil=0</code> or set <code>PYTHON_GIL=0</code> in your shell environment while running tests to ensure the GIL is actually disabled during tests, at least until you can register that your extension modules support disabling the GIL via <code>Py_mod_gil</code> and all of your runtime test dependencies do the same. See the porting guide for more information about declaring support for free-threaded python in your extension.</p>"},{"location":"debugging/","title":"Uncovering concurrency issues, testing and debugging","text":"<p>Until now, the GIL has allowed developers to ignore C safety issues when writing parallel programs, since the GIL ensured that all thread execution was serialized, allowing for simultaneous access to Python objects and state defined in the interpreter.</p> <p>The new free-threaded model ensures that Python code access originating from other Python code frames is safe and is guaranteed to not produce any major interpreter crash, as opposed to unrestricted C code access, which can present any of the common C thread-safety issues.</p> <p>Usually, concurrency issues arise when two or more threads try to modify the same value in memory. In Python, this commonly occurs when a class or function defines native shared state, either via an attribute or a variable that can be modified from native code in each thread execution scope.</p> <p>The most common issues related to concurrency in the context of free-threaded CPython extensions are either dirty reads/writes to global/shared C state, unexpected behavior due to simultaneous access to C calls that are not thread-safe, and finally, major runtime crashes due to memory allocation issues and forbidden pointer lookups. While the first case depends on the actual implementation of the algorithm/routine and may produce unintended results, it would not cause a fatal crash of the interpreter, as opposed to the last two cases.</p> <p>In order to discover, handle and debug concurrency issues at large, there are several strategies, which we will summarize next.</p>"},{"location":"debugging/#ensure-that-an-extension-module-is-free-threaded-compliant","title":"Ensure that an extension module is free-threaded compliant","text":"<p>We highly suggest reading the detailed guide presented on Porting Extension Modules to Support Free-Threading</p>"},{"location":"debugging/#testing-scenarios","title":"Testing scenarios","text":"<p>In order to check that a function or class has no concurrency issues, it is necessary to define test functions that cover such cases. For such scenarios, the standard <code>threading</code> library defines several low-level parallel primitives that can be used to test for concurrency, while the <code>concurrent.futures</code> module provides high-level constructs.</p> <p>For example, consider a method <code>MyClass.call_unsafe</code> that has been flagged as having concurrency issues since it mutates attributes of a shared object that is accessed by multiple threads. We can write a test for it using first low-level primitives:</p> <pre><code>\"\"\"test_concurrent.py\"\"\"\n\n# Low level parallel primitives\nimport threading\n\n# High level parallel constructs\nfrom concurrent.futures import ThreadPoolExecutor\n\n# Library to test\nfrom mylib import MyClass\n\n\ndef test_call_unsafe_concurrent_threading():\n    # Defines a thread barrier that will be spawned before parallel execution\n    # this increases the probability of concurrent access clashes.\n    n_threads = 10\n    barrier = threading.Barrier(n_threads)\n\n    # This object will be shared by all the threads.\n    cls_instance = MyClass(...)\n\n    results = []\n\n    def closure():\n        # Ensure that all threads reach this point before concurrent execution.\n        barrier.wait()\n        r = cls_instance.call_unsafe()\n        results.append(r)\n\n    # Spawn n threads that call call_unsafe concurrently.\n    workers = []\n    for _ in range(0, n_threads):\n        workers.append(threading.Thread(target=closure))\n\n    for worker in workers:\n        worker.start()\n\n    for worker in workers:\n        worker.join()\n\n    # Do something about the results\n    assert check_results(results)\n\n\ndef test_call_unsafe_concurrent_pool():\n    # Defines a thread barrier that will be spawned before parallel execution\n    # this increases the probability of concurrent access clashes.\n    n_threads = 10\n    barrier = threading.Barrier(n_threads)\n\n    # This object will be shared by all the threads.\n    cls_instance = MyClass(...)\n\n    def closure():\n        # Ensure that all threads reach this point before concurrent execution.\n        barrier.wait()\n        r = cls_instance.call_unsafe()\n        return r\n\n    with ThreadPoolExecutor(max_workers=n_threads) as executor:\n        futures = [executor.submit(closure) for _ in range(n_threads)]\n\n    results = [f.result() for f in futures]\n\n    # Do something about the results\n    assert check_results(results)\n</code></pre> <p>Given the non-deterministic nature of parallel execution, such tests may pass from time to time. In order to reliably ensuring their failure under concurrency, we recommend using <code>pytest-repeat</code>, which enables the <code>--count</code> flag in the <code>pytest</code> command:</p> <pre><code># Setting PYTHON_GIL=0 ensures that the GIL is effectively disabled.\nPYTHON_GIL=0 pytest -x -v --count=100 test_concurrent.py\n</code></pre> <p>We advise to set <code>count</code> in the order of hundreds and even larger, in order to ensure at least one concurrent clash event.</p>"},{"location":"debugging/#debugging-tests-that-depend-on-native-calls","title":"Debugging tests that depend on native calls","text":"<p>If your code has native dependencies, either via C/C++ or Cython, <code>gdb</code> (or <code>lldb</code>) can be used as follows:</p> <pre><code># Setting PYTHON_GIL=0 ensures that the GIL is effectively disabled.\nPYTHON_GIL=0 gdb --args python my_program.py --args ...\n\n# To test under pytest\nPYTHON_GIL=0 gdb --args python -m pytest -x -v \"test_here.py::TestClass::test_method\"\n\n# Using LLDB (under LLVM/clang)\nPYTHON_GIL=0 lldb -- $(which python) my_program.py\n\n# Using LLDB (and pyenv)\nPYTHON_GIL=0 lldb -- $(pyenv which python) $(pyenv which pytest) -x -v \"test_here.py::TestClass::test_method\"\n</code></pre> <p>When Python is run under <code>gdb</code>, several Python integration commands will be available, such commands start with the <code>py-</code> prefix. For instance, the <code>py-bt</code> allows to obtain a Python interpreter backtrace whenever the debugger hits a native frame, this allows to improve the tracking of execution between Python and native frames<sup>1</sup>.</p> <p>For more information about <code>gdb</code> and <code>lldb</code> commands, we encourage reading the GDB to LLDB command map page in the official LLVM docs.</p>"},{"location":"debugging/#cython-debugging","title":"Cython debugging","text":"<p>Since Cython produces intermediate C/C++ sources that then are compiled into native code, stepping through may get difficult if done solely from the C source file. In order to get through such difficulty, Cython includes the <code>cygdb</code> extension, which enables <code>gdb</code> to go through large sections of C code that are equivalent to a single Cython declaration.</p> <p>Enabling <code>cygdb</code> requires the compilation of Cython sources with the <code>--gdb</code> flag. After the sources are compiled and linked, it can be used as follows:</p> <pre><code># For example, running the tests of scikit-image.\n# build/cp313td/ contains the trace files generated by Cython to be compatible\n# with cygdb\nPYTHON_GIL=0 cygdb build/cp313td/ -- --args python -m  pytest -x -v skimage/\n</code></pre> <p>Since <code>cygdb</code> requires the Python interpreter version used to compile <code>gdb</code> to match the one to be used during the execution of the script, recompiling <code>gdb</code> will be necessary in order to ensure the most complete debugging experience. We recommend the <code>gdb</code> compilation instructions provided by the Linux from scratch project.</p> <p><code>cygdb</code> defines a set of commands prefixed by <code>cy</code> that replace the usual <code>gdb</code> commands. For example <code>cy run</code> will start the program with the Cython debugging extensions enabled, <code>cy break</code> will define a breakpoint on a function with the Cython definition name, <code>cy next</code> will step over a Cython line, which is equivalent to several lines in the produced C code.</p>"},{"location":"debugging/#detecting-issues-in-cpython","title":"Detecting issues in CPython","text":"<p>If a debugging session suggests that an error/bug is incoming from CPython, we recommend installing a debug instance. The easiest way to accomplish this is via <code>pyenv</code>:</p> <pre><code>pyenv install --debug --keep 3.13t-dev\n</code></pre> <p>This command will not only install a debug distribution of CPython, but also will ensure that the source files are kept as well, such files will be loaded by <code>gdb</code>/<code>lldb</code> at the moment of debugging. For more information regarding CPython installation sources, please visit the Installing a free-threaded Python page.</p>"},{"location":"debugging/#frequently-seen-errors-and-how-to-fix-them","title":"Frequently seen errors and how to fix them","text":"<p>These are error messages that we see come up often when working with code or development workflows that have not been updated to accommodate the free-threaded build. We also provide suggested fixes. Please send in pull requests to the repository for this document if you run into any confusing free-threading-specific errors that you suspect apply to other libraries and aren't covered here.</p>"},{"location":"debugging/#cython-compilation-errors-unknown-type-name-__pyx_vectorcallfunc","title":"Cython compilation errors: <code>unknown type name '__pyx_vectorcallfunc'</code>","text":"<p>This happens if you try to build a Cython extension for the free-threaded build using the current stable release of Cython (3.0.10 at the time of writing). The current stable release of Cython does not support the free-threaded build. You must either build Cython from the <code>master</code> branch on Github or use the nightly wheel:</p> <pre><code>pip install -i https://pypi.anaconda.org/scientific-python-nightly-wheels/simple cython\n</code></pre> <p>See the porting guide for more detail about porting Cython code to work under free-threading.</p> <p>You may wonder why you are able to install a wheel for the current Cython release at all. This is because Cython ships a pure-python wheel tagged with <code>py2.py3-none-any</code>, which pip will install if it cannot find another wheel that is compatible. A future version of Cython will ship a wheel with compiled code that supports the free-threaded build.</p> <p>The current nightly wheel is a pure-python build, so it works on all architectures. The pure-python version of Cython is usually only marginally slower than a compiled version, so you should default to installing the wheel in CI instead of compiling Cython, which can take up to a few minutes on some CI runners.</p> <ol> <li> <p>This feature is not correctly working on <code>lldb</code> after CPython 3.12.\u00a0\u21a9</p> </li> </ol>"},{"location":"installing_cpython/","title":"Installing a free-threaded Python","text":"<p>To install a free-threaded CPython interpreter, you can either use a pre-built binary or build CPython from source. The former is quickest to get started with. Building from source is not too difficult either though, and in case you hit a bug that may involve CPython itself then you may want to build from source.</p>"},{"location":"installing_cpython/#binary-install-options","title":"Binary install options","text":"<p>There are a growing number of options to install a free-threaded interpreter, from the python.org installers to Linux distro and Conda package managers.</p> <p>Note</p> <p>For any of these options, please check after the install succeeds that you have a <code>pip</code> version that is recent enough (<code>&gt;=24.1</code>), and upgrade it if that isn't the case. Older <code>pip</code> versions will select wheels with the <code>cp313</code> tag (binary-incompatible) rather than the <code>cp313t</code> tag.</p> As a packager, what should I name the package and interpreter? <p>Please see this guidance from the Python Steering Council</p>"},{"location":"installing_cpython/#pythonorg-installers","title":"python.org installers","text":"<p>The python.org downloads page provides macOS and Windows installers that have experimental support. Note that you have to customize the install - e.g., for Windows there is a Download free-threaded binaries checkbox under \"Advanced Options\". See also the Using Python on Windows section of the Python 3.13 docs.</p> <p>Automating the process of downloading the official installers and installing the free-threaded binaries is also possible:</p> WindowsmacOS <p>On Windows, you can invoke the installer from the command-line prompt:</p> <pre><code>$url = 'https://www.python.org/ftp/python/3.13.0/python-3.13.0rc2-amd64.exe'\nInvoke-WebRequest -Uri $url -OutFile 'python.exe'\npython.exe /quiet Include_freethreaded=1\n</code></pre> <p>If you are running this script without administrator privileges, a UAC prompt will trigger when you try to run the installer. The resulting Python installation will be available afterwards in <code>AppData\\Local\\Programs\\Python\\Python313\\python3.13t.exe</code>. See Installing Without UI for more information.</p> <p>On macOS, you can use <code>installer</code> to install a macOS package you've downloaded:</p> <pre><code>curl -O https://www.python.org/ftp/python/3.13.0/python-3.13.0rc2-macos11.pkg\n\n# create installer choice changes to customize the install:\n#    enable the PythonTFramework-3.13 package\n#    while accepting the other defaults (install all other packages)\ncat &gt; ./choicechanges.plist &lt;&lt;EOF\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;\n&lt;plist version=\"1.0\"&gt;\n&lt;array&gt;\n        &lt;dict&gt;\n                &lt;key&gt;attributeSetting&lt;/key&gt;\n                &lt;integer&gt;1&lt;/integer&gt;\n                &lt;key&gt;choiceAttribute&lt;/key&gt;\n                &lt;string&gt;selected&lt;/string&gt;\n                &lt;key&gt;choiceIdentifier&lt;/key&gt;\n                &lt;string&gt;org.python.Python.PythonTFramework-3.13&lt;/string&gt;\n        &lt;/dict&gt;\n&lt;/array&gt;\n&lt;/plist&gt;\nEOF\n\nsudo installer -pkg ./python-3.13.0rc2-macos11.pkg \\\n    -applyChoiceChangesXML ./choicechanges.plist \\\n    -target /\nrm -f python-3.13.0rc2-macos11.pkg\n</code></pre> <p>See also this Github issue for more information.</p>"},{"location":"installing_cpython/#linux-distros","title":"Linux distros","text":"FedoraNixpkgsUbuntu <p>Fedora ships a packaged version, which you can install with:</p> <pre><code>sudo dnf install python3.13-freethreading\n</code></pre> <p>This will install the interpreter at <code>/usr/bin/python3.13t</code>.</p> <p>Nixpkgs provides cached builds under the <code>python313FreeThreading</code> attribute from NixOS 24.05 and newer.</p> <p>With <code>flakes</code> enabled the following command will drop you in an ephemeral shell:</p> <pre><code>nix shell nixpkgs#python313FreeThreading\n</code></pre> <p>Without <code>flakes</code>, make sure to update your nixpkgs channel first:</p> <pre><code>sudo nix-channel --update\nnix-shell -p python313FreeThreading\n</code></pre> <p>For Ubuntu you can use the deadsnakes PPA by adding it to your repositories and then installing <code>python3.13-nogil</code>:</p> <pre><code>sudo add-apt-repository ppa:deadsnakes\nsudo apt-get update\nsudo apt-get install python3.13-nogil\n</code></pre>"},{"location":"installing_cpython/#conda-forge","title":"Conda-forge","text":"<pre><code>mamba create -n nogil -c conda-forge/label/python_rc python-freethreading\n</code></pre>"},{"location":"installing_cpython/#containers","title":"Containers","text":"<p>The manylinux containers have free-threaded builds. You can use any of the actively supported images:</p> <ul> <li><code>quay.io/pypa/manylinux2014_...</code></li> <li><code>quay.io/pypa/manylinux_2_28_...</code></li> <li><code>quay.io/pypa/musllinux_1_1_...</code></li> <li><code>quay.io/pypa/musllinux_1_2_...</code></li> </ul> <p>Replace <code>...</code> with your desired architecture, such as <code>x86_64</code> or <code>aarch64</code>.</p> <p>These images have <code>python3.13t</code> available, along with other commonly used tools that can target it like the latest <code>pip</code>, <code>pipx</code>, and <code>uv</code>.</p>"},{"location":"installing_cpython/#building-from-source","title":"Building from source","text":"<p>Currently we suggest building CPython from source using the latest version of the CPython <code>main</code> branch. See the build instructions in the CPython developer guide. You will need to install needed third-party dependencies before building. To build the free-threaded version of CPython, pass <code>--disable-gil</code> to the <code>configure</code> script:</p> <pre><code>./configure --with-pydebug --disable-gil\n</code></pre> <p>If you will be switching Python versions often, it may make sense to build CPython using pyenv. In order to do that, you can use the following:</p> <pre><code>pyenv install --debug 3.13t-dev\n</code></pre>"},{"location":"porting/","title":"Porting Extension Modules to Support Free-Threading","text":"<p>Many Python extension modules are not thread-safe in the free-threaded build as of mid-2024. Up until now, the GIL has added implicit locking around any operation in Python or C that holds the GIL, and the GIL must be explicitly dropped before many thread-safety issues become problematic. Also, because of the GIL, attempting to parallelize many workflows using the Python threading module will not produce any speedups, so thread-safety issues that are possible even with the GIL are not hit often since users do not make use of threading as much as other parallelization strategies. This means many codebases have threading bugs that up-until-now have only been theoretical or present in niche use cases. With free-threading, many more users will want to use Python threads.</p> <p>This means we must analyze the codebases of extension modules to identify thread-safety issues and make changes to thread-unsafe low-level code, including C, C++, and Cython code exposed to Python.</p>"},{"location":"porting/#declaring-free-threaded-support","title":"Declaring free-threaded support","text":"<p>Extension modules need to explicitly indicate they support running with the GIL disabled, otherwise a warning is printed and the GIL is re-enabled at runtime after importing a module that does not support the GIL.</p> C APIPybind11Cythonf2py <p>C or C++ extension modules using multi-phase initialization can specify the <code>Py_mod_gil</code> module slot like this:</p> <pre><code>static PyModuleDef_Slot module_slots[] = {\n    ...\n#ifdef Py_GIL_DISABLED\n    {Py_mod_gil, Py_MOD_GIL_NOT_USED},\n#endif\n    {0, NULL}\n};\n</code></pre> <p>The <code>Py_mod_gil</code> slot has no effect in the non-free-threaded build.</p> <p>Extensions that use single-phase initialization need to call <code>PyUnstable_Module_SetGIL()</code> in the module's initialization function:</p> <pre><code>PyMODINIT_FUNC\nPyInit__module(void)\n{\n    PyObject *mod = PyModule_Create(&amp;module);\n    if (mod == NULL) {\n        return NULL;\n    }\n\n#ifdef Py_GIL_DISABLED\n    PyUnstable_Module_SetGIL(mod, Py_MOD_GIL_NOT_USED);\n#endif\n\n    return mod;\n}\n</code></pre> <p>C++ extension modules making use of <code>pybind11</code> can easily declare support for running with the GIL disabled via the <code>gil_not_used</code> argument to <code>create_extension_module</code>. Example:</p> <pre><code>#include &lt;pybind11/pybind11.h&gt;\nnamespace py = pybind11;\n\nPYBIND11_MODULE(example, m, py::mod_gil_not_used()) {\n    ...\n}\n</code></pre> <p>Starting with Cython 3.1.0 (only available via the nightly wheels or the <code>master</code> branch as of right now), extension modules written in Cython can do so using the <code>freethreading_compatible</code> compiler directive.</p> <p>You can do this in one of several ways, e.g., in a source file:</p> <pre><code># cython: freethreading_compatible=True\n</code></pre> <p>Or by passing the directive when invoking the <code>cython</code> executable:</p> <pre><code>$ cython -X freethreading_compatible=True\n</code></pre> <p>Or via a build system specific way of passing directives to Cython.</p> <p>Tip</p> <p>Here are a few examples of how to globally enable the directive in a few popular build systems:</p> setuptoolsMeson <p>When using setuptools, you can pass the <code>compiler_directives</code> keyword argument to <code>cythonize</code>:</p> <pre><code>from Cython.Compiler.Version import version as cython_version\nfrom packaging.version import Version\n\ncompiler_directives = {}\nif Version(cython_version) &gt;= Version(\"3.1.0a1\"):\n    compiler_directives[\"freethreading_compatible\"] = True\n\nsetup(\n    ext_modules=cythonize(\n        extensions,\n        compiler_directives=compiler_directives,\n    )\n)\n</code></pre> <p>When using Meson, you can add the directive to the <code>cython_args</code> you're passing to <code>py.extension_module</code>:</p> <pre><code>cy = meson.get_compiler('cython')\n\ncython_args = []\nif cy.version().version_compare('&gt;=3.1.0')\n    cython_args += ['-Xfreethreading_compatible=True']\nendif\n\npy.extension_module('modulename'\n    'source.pyx',\n    cython_args: cython_args,\n    ...\n)\n</code></pre> <p>You can also globally add the directive for all Cython extension modules:</p> <pre><code>cy = meson.get_compiler('cython')\nif cy.version().version_compare('&gt;=3.1.0')\n    add_project_arguments('-Xfreethreading_compatible=true', language : 'cython')\nendif\n</code></pre> <p>In CI, you will need to ensure a nightly cython is installed for free-threaded builds. See the docs on setting up CI for advice on how to build projects that depend on Cython.</p> <p>Starting with NumPy 2.1.0 (only available via the nightly wheels or the <code>main</code> branch as of right now), extension modules containing f2py-wrapped Fortran code can declare they are thread safe and support free-threading using the <code>--freethreading-compatible</code> command-line argument:</p> <pre><code>$ python -m numpy.f2py -c code.f -m my_module --freethreading-compatible\n</code></pre> <p>If you publish binaries and have downstream libraries that depend on your library, we suggest adding support as described above and uploading nightly wheels as soon as basic support for the free-threaded build is established in the development branch. This will ease the work of libraries that depend on yours to also add support for the free-threaded build.</p>"},{"location":"porting/#suggested-plan-of-attack","title":"Suggested Plan of Attack","text":"<p>Put priority on thread-safety issues surfaced by real-world testing. Run the test suite for your project and fix any failures that occur only with the GIL disabled. Some issues may be due to changes in Python 3.13 that are not specific to the free-threaded build.</p> <p>Definitely run your existing test suite with the GIL disabled, but unless your tests make heavy use of the <code>threading</code> module, you will likely not hit many issues, so also consider constructing multithreaded tests to expose bugs based on workflows you want to support. Issues found in these tests are the issues your users will most likely hit first. The <code>concurrent.futures.ThreadPoolExecutor</code> class is a lightweight way to create multithreaded tests where many threads repeatedly call a function simultaneously. You can also use the <code>threading</code> module directly. Adding a <code>threading.Barrier</code> before your test code is a good way to synchronize workers and encourage a race condition.</p> <p>Many C and C++ extensions assume the GIL serializes access to state shared between threads, introducing the possibility of data races and race conditions that were impossible before when the GIL is disabled.</p> <p>Cython code can also be thread-unsafe and exhibit undefined behavior due to data races just like any other C or C++ code. However, code operating on Python objects should not exhibit any low-level data races or undefined behavior due to Python-level semantics. If you find such a case, it may be a Cython or CPython bug and should be reported as such. That said, race conditions are allowed in Python and therefore Cython as well, so you will still need to add locking or synchronization where appropriate to ensure reproducible results when running a multithreaded algorithm on shared mutable data.</p> <p>The CPython C API exposes the <code>Py_GIL_DISABLED</code> macro in the free-threaded build. You can use it to enable low-level code that only runs under the free-threaded build, isolating possibly performance-impacting changes to the free-threaded build:</p> <pre><code>#ifdef Py_GIL_DISABLED\n// free-threaded specific code goes here\n#endif\n\n#ifndef Py_GIL_DISABLED\n// code for gil-enabled builds goes here\n#endif\n</code></pre> <p>We suggest focusing on safety over single-threaded performance. For example, if adding a lock to a global cache would harm multithreaded scaling, and turning off the cache implies a a small performance hit, consider doing the simpler thing and disabling the cache in the free-threaded build. Single-threaded performance can always be improved later, once you've established free-threaded support and hopefully improved test coverage for multithreaded workflows.</p> <p>For NumPy, we are generally assuming users will not do pathological things like resizing an array while another thread is reading from or writing to it and do not explicitly account for this. Eventually we will need to add locking around data structures to avoid races caused by issues like this, but in this early stage of porting we are not planning to add locking on every operation exposed to users that mutates data. Locking will likely need to be added in the future, but that should be done carefully and with experience informed by real-world multithreaded scaling.</p> <p>For your libraries, we suggest a similar approach for now. Focus on thread safety issues that only occur with the GIL disabled. Any non-critical pre-existing thread safety issues can be dealt with later once the free-threaded build is used more. The goal for now should be to enable further refinement and experimentation by fixing issues that prevent using the library at all.</p>"},{"location":"porting/#locking-and-synchronization-primitives","title":"Locking and Synchronization Primitives","text":"<p>If your extension is written in C++, Rust, or another modern language that exposes locking primitives in the standard library, you should consider using the locking primitives provided by your language or framework to add locks when needed.</p> <p>For C code or C-like C++ code, the CPython 3.13 C API exposes <code>PyMutex</code>, a high-performance locking primitive that supports static allocation. As of CPython 3.13, the mutex requires only one byte for storage, but future versions of CPython may change that, so you should not rely on the size of <code>PyMutex</code> in your code.</p>"},{"location":"porting/#global-state","title":"Global state","text":"<p>Many CPython C extensions make strong assumptions about the GIL. For example, before NumPy 2.1.0, the C code in NumPy made extensive use of C static global variables for storing settings, state, and caches. With the GIL, it is possible for Python threads to produce non-deterministic results from a calculation, but it is not possible for two C threads to simultaneously see the state of the C global variables, so no data races are possible.</p> <p>In free-threaded Python, global state like this is no longer safe against data races and undefined behavior in C code. A cache of <code>PyObject</code>s stored in a C global pointer array can be overwritten simultaneously by multiple Python threads, leading to memory corruption and segfaults.</p>"},{"location":"porting/#converting-to-thread-local-state","title":"Converting to thread local state","text":"<p>Often the easiest way to fix data races due to global state is to convert the global state to thread local state.</p> <p>Python and Cython code can make use of <code>threading.local</code> to declare a thread-local Python object. C and C++ code can also use the <code>Py_tss API</code> to store thread-local Python object references. PEP 539 has more details about the <code>Py_tss</code> API.</p> <p>Low-level C or C++ code can make use of the <code>thread_local</code> storage specified by recent standard versions. Note that standardization of thread-local storage in C has been slower than C++, so you may need to use platform-specific definitions to declare variables with thread-local storage. Also note that thread-local storage on MSVC has caveats, and you should not use thread-local storage for anything besides statically defined integers and pointers.</p> <p>NumPy has a <code>NPY_TLS</code> macro in the <code>numpy/npy_common.h</code> header. While you can include the numpy header and use <code>NPY_TLS</code> directly on NumPy 2.1 or newer, you can also add the definition to your own codebase, along with some build configuration tests to test for the correct definition to use.</p>"},{"location":"porting/#caches","title":"Caches","text":"<p>Global caches are also a common source of thread safety issues. For example, if a function requires an expensive intermediate result that only needs to be calculated once, many C extensions store the result in a global variable. This can lead to data races and memory corruption if more than one thread simultaneously tries to fill the cache.</p> <p>If the cache is not critical for performance, consider simply disabling the cache in the free-threaded build:</p> <pre><code>static int *cache = NULL;\n\nint my_function_with_a_cache(void) {\n    int *my_cache = NULL;\n#ifndef Py_GIL_DISABLED\n    if (cache == NULL) {\n        cache = get_expensive_result();\n    }\n    my_cache = cache;\n#else\n    my_cache = get_expensive_result();\n#endif;\n    // use the cache\n}\n</code></pre> <p>CPython holds a per-module lock during import. This lock can be released to avoid deadlocks in unusual cases, but in most situations module initialization happens exactly once per interpreter in one C thread. Modules using static single-phase initialization can therefore set up per-module state in the <code>PyInit</code> function without worrying about concurrent initialization of modules in different threads. For example, you might set up a global static cache that is read-only after module initialization like this:</p> <pre><code>static int *cache = NULL;\n\nPyMODINIT_FUNC\nPyInit__module(void)\n{\n    PyObject *mod = PyModule_Create(&amp;module);\n    if (mod == NULL) {\n        return NULL;\n    }\n\n    // don't need to lock or do anything special\n    cache = setup_cache();\n\n    // do rest of initialization\n}\n</code></pre> <p>You can then read from <code>cache</code> at runtime in a context where you know the module is initialized without worrying about whether or not the per-module static cache is initialized.</p> <p>If the cache is critical for performance, cannot be generated at import time, but generally gets filled quickly after a program begins, then you will need to use a single-initialization API to ensure the cache is only ever initialized once. In C++, use <code>std::once_flag</code> or <code>std::call_once</code>.</p> <p>C does not have an equivalent portable API for single initialization. If you need that, take a look at this NumPy PR for an example using atomic operations and a global mutex.</p> <p>If the cache is in the form of a data container, then you can lock access to the container, like in the following example:</p> <pre><code>#ifdef Py_GIL_DISABLED\nstatic PyMutex cache_lock = {0};\n#define LOCK() PyMutex_Lock(&amp;cache_lock)\n#define UNLOCK() PyMutex_Unlock(&amp;cache_lock)\n#else\n#define LOCK()\n#define UNLOCK()\n#endif\n\nstatic int *cache = NULL;\nstatic PyObject *global_table = NULL;\n\nint initialize_table(void) {\n    // called during module initialization\n    global_table = PyDict_New();\n    return;\n}\n\nint function_accessing_the_cache(void) {\n    LOCK();\n    // use the cache\n\n    UNLOCK();\n}\n</code></pre> <p>Note</p> <p>Note that, while the NumPy PR linked above uses <code>PyThread_type_lock</code>, that is only because <code>PyMutex</code> was not part of the public Python C API at the time. We recommended always using <code>PyMutex</code>. For pointers on how to do that, check this NumPy PR that ports all <code>PyThread_type_lock</code> usages to <code>PyMutex</code>.</p>"},{"location":"porting/#dealing-with-thread-unsafe-libraries","title":"Dealing with thread-unsafe libraries","text":"<p>Many C, C++, and Fortran libraries are not written in a thread-safe manner. It is still possible to call these libraries from free-threaded Python, but wrappers must add appropriate locks to prevent undefined behavior.</p> <p>There are two kinds of thread unsafe libraries: reentrant and non-reentrant. A reentrant library generally will expose state as a struct that must be passed to library functions. So long as the state struct is not shared between threads, functions in the library can be safely executed simultaneously.</p> <p>Wrapping reentrant libraries requires adding locking whenever the state struct is accessed.</p> <pre><code>typedef struct lib_state_struct {\n    low_level_library_state *state;\n    PyMutex lock;\n} lib_state_struct;\n\nint call_library_function(lib_state_struct *lib_state) {\n    PyMutex_Lock(&amp;lib_state-&gt;lock);\n    library_function(lib_state-&gt;state);\n    PyMutex_Unlock(&amp;lib_state-&gt;lock)\n}\n\nint call_another_library_function(lib_state_struct *lib_state) {\n    PyMutex_Lock(&amp;lib_state-&gt;lock);\n    another_library_function(lib_state-&gt;state);\n    PyMutex_Unlock(&amp;lib_state-&gt;lock)\n}\n</code></pre> <p>With this setup, if two threads call <code>library_function</code> and <code>another_library_functions</code> simultaneously, one thread will block until the other thread finishes, preventing concurrent access to <code>lib_state-&gt;state</code>.</p> <p>Non-reentrant libraries provide an even weaker guarantee: threads cannot call library functions simultaneously without causing undefined behavior. Generally this is due to use of global static state in the library. This means that non-reentrant libraries require a global lock:</p> <pre><code>static PyMutex global_lock = {0};\n\nint call_library_function(int *argument) {\n    PyMutex_Lock(&amp;global_lock);\n    library_function(argument);\n    PyMutex_Unlock(&amp;global_lock);\n}\n</code></pre> <p>Any other wrapped function needs similar locking around each call into the library.</p>"},{"location":"porting/#dealing-with-thread-unsafe-objects","title":"Dealing with thread-unsafe objects","text":"<p>Similar to the section above, objects may need locking or atomics if they can be concurrently modified from multiple threads. CPython 3.13 exposes a public C API that allows users to use the built-in per-object locks.</p> <p>For example the following code:</p> <pre><code>int do_modification(MyObject *obj) {\n    return modification_on_obj(obj);\n}\n</code></pre> <p>Should be transformed to:</p> <pre><code>int do_modification(MyObject *obj) {\n    int res;\n    Py_BEGIN_CRITICAL_SECTION(obj);\n    res = modification_on_obj(obj);\n    Py_END_CRITICAL_SECTION(obj);\n    return res;\n}\n</code></pre> <p>A variant for locking two objects at once is also available. For more information about <code>Py_BEGIN_CRITICAL_SECTION</code>, please see the Python C API documentation on critical sections.</p>"},{"location":"porting/#cython-thread-safety","title":"Cython thread-safety","text":"<p>If your extension is written in Cython, you can generally assume that \"Python-level\" code that compiles to CPython C API operations on Python objects is thread safe, but \"C-level\" code (e.g. code that will compile inside a <code>with nogil</code> block) may have thread-safety issues. Note that not all code outside <code>with nogil</code> blocks is thread safe. For example, a Python wrapper for a thread-unsafe C library is thread-unsafe if the GIL is disabled unless there is locking around uses of the thread-unsafe library. Another example: using thread-unsafe C-level constructs like a global variable is also thread-unsafe if the GIL is disabled.</p>"},{"location":"porting/#cpython-c-api-usage","title":"CPython C API usage","text":"<p>In the free-threaded build it is possible for the reference count of an object to change \"underneath\" a running thread when it is mutated by another thread. This means that many APIs that assume reference counts cannot be updated by another thread while it is running are no longer thread safe. In particular, C code returning \"borrowed\" references to Python objects in mutable containers like lists may introduce thread-safety issues. A borrowed reference happens when a C API function does not increment the reference count of a Python object before returning the object to the caller. \"New\" references are safe to use until the owning thread releases the reference, as in non free-threaded code.</p> <p>Most direct uses of the CPython C API are thread safe. There is no need to add locking for scenarios that should be bugs in CPython. You can assume, for example, that the initializer for a Python object can only be called by one thread and the C-level implementation of a Python function can only be called on one thread. Accessing the arguments of a Python function is thread safe no matter what C API constructs are used and no matter whether the reference is borrowed or owned because two threads can't simultaneously call the same function with the same arguments from the same Python-level context. Of course it's possible to implement argument parsing in a thread-unsafe manner using thread-unsafe C or C++ constructs, but it's not possible to do so using the CPython C API.</p>"},{"location":"porting/#unsafe-apis-returning-borrowed-references","title":"Unsafe APIs returning borrowed references","text":"<p>The <code>PyDict</code> and <code>PyList</code> APIs contain many functions returning borrowed references to items in dicts and lists. Since these containers are mutable, it's possible for another thread to delete the item from the container, leading to the item being de-allocated while the borrowed reference is still \"alive\". Even code like this:</p> <pre><code>PyObject *item = Py_NewRef(PyList_GetItem(list_object, 0))\n</code></pre> <p>Is not thread safe, because in principle it's possible for the list item to be de-allocated before <code>Py_NewRef</code> gets a chance to increment the reference count.</p> <p>For that reason, you should inspect Python C API code to look for patterns where a borrowed reference is returned to a shared, mutable data structure, and replace uses of APIs like <code>PyList_GetItem</code> with APIs exposed by the CPython C API returning strong references like <code>PyList_GetItemRef</code>. Not all usages are problematic (see above) and we do not currently suggest converting all usages of possibly unsafe APIs returning borrowed references to return new reference. This would introduce unnecessary reference count churn in situations that are thread-safe by construction and also likely introduce new reference counting bugs in C or C++ code using the C API directly. However, many usages are unsafe, and maintaining a borrowed reference to an objects that could be exposed to another thread is unsafe.</p> <p>A good starting place to find instances of this would be to look for usages of the unsafe borrowed reference APIs mentioned in the free-threading compatibility docs.</p>"},{"location":"porting/#adopt-pythoncapi-compat-to-use-new-c-api-functions","title":"Adopt <code>pythoncapi-compat</code> to use new C API functions","text":"<p>Rather than maintaining compatibility shims to use functions added to the C API for Python 3.13 like <code>PyList_GetItemRef</code> while maintaining compatibility with earlier Python versions, we suggest adopting the <code>pythoncapi-compat</code> project as a build-time dependency. This is a header-only library that can be vendored as e.g. a git submodule and included to expose shims for C API functions on older versions of Python that do not have implementations.</p>"},{"location":"porting/#some-low-level-apis-dont-enforce-locking","title":"Some low-level APIs don't enforce locking","text":"<p>Some low-level functions like <code>PyList_SET_ITEM</code> and <code>PyTuple_SET_ITEM</code> do not do any internal locking and should only be used to build newly created values. Do not use them to modify existing containers in the free-threaded build.</p>"},{"location":"porting/#limited-api-support","title":"Limited API support","text":"<p>The free-threaded build does not support the limited CPython C API. If you currently use the limited API you will not be able to use it while shipping binaries for the free-threaded build. This also means that code inside <code>#ifdef Py_GIL_DISABLED</code> checks can use C API constructs outside the limited API if you would like to do that, although these uses will need to be removed once the free-threaded build gains support for compiling with the limited API.</p>"},{"location":"running-gil-disabled/","title":"Running with the GIL disabled","text":"<p>Info</p> <p>Most of the content on this page is also covered in the Python 3.13 release notes.</p> <p>Note</p> <p>The free-threaded Python executable will always have a <code>python3.13t</code> alias (for Python 3.13); whether <code>python</code>, <code>python3</code> and/or <code>python3.13</code> point at the free-threaded executable or not will depend on the installation method (see the install guide for more details).</p> <p>For example, the Python 3.13 Windows installer from python.org installs the free-threaded binary as <code>python3.13t.exe</code> (with a \"t\" suffix to indicate it is \"t\"hreaded), whereas the standard GIL-enabled Python binary is simply named <code>python.exe</code> (as usual). If you cannot find the free-threaded binary, that means the free-threaded option was not selected during installation.</p> <p>You can verify your build of CPython itself has the GIL disabled with the following incantation:</p> <pre><code>python -VV\n</code></pre> <p>If you are using Python 3.13b1 or newer, you should see a message like:</p> <pre><code>Python 3.13.0b1+ experimental free-threading build (heads/3.13:d93c4f9, May 21 2024, 10:54:14) [Clang 15.0.0 (clang-1500.1.0.2.5)]\n</code></pre> <p>Verify that the GIL is disabled at runtime with the following incantation:</p> <pre><code>python -c \"import sys; print(sys._is_gil_enabled())\"\n</code></pre> <p>To force Python to keep the GIL disabled even after importing a module that does not support running without it, use the <code>PYTHON_GIL</code> environment variable or the <code>-X gil</code> command line option:</p> <pre><code># these are equivalent\nPYTHON_GIL=0 python\npython -Xgil=0\n</code></pre>"},{"location":"tracking/","title":"Compatibility status tracking","text":"<p>This page tracks the status of packages for which we're aware of active work on free-threaded support. It contains packages with extension modules, as well as build tools and packages that needed code specifically to support free-threading. Note that pure Python code works without changes by design, hence this page does not aim to track pure Python packages.</p> <p>If there's a bug related to free-threading in a library you use, please open an issue on the corresponding issue tracker or post a comment on the corresponding free-threading support tracking issue (see table below). If an issue spans multiple projects or there's an ecosystem-wide point to discuss, please open an issue on this issue tracker.</p> <p>Tip</p> <p>It's early days for free-threaded support - bugs in CPython itself and in widely used libraries with extension modules are being fixed every week. It may be useful to use nightly wheels (when available) of packages like <code>cython</code> or <code>numpy</code>, even if a first release is available on PyPI. For example, you can install a NumPy nightly wheel by running:</p> <pre><code>pip install -i https://pypi.anaconda.org/scientific-python-nightly-wheels/simple numpy\n</code></pre> Project Upstream issue Tested in CI PyPI release First version with support Nightly wheels Nightly link cffi 1.18 cibuildwheel 2.19 CMake 3.30.0 <sup>1</sup> ContourPy 1.3.0 Cython 3.1.0 joblib 1.4.2 matplotlib 3.9.0 Meson 1.5.0 meson-python 0.16.0 multidict mypyc Nuitka NumPy 2.1.0 nanobind 2.2.0 packaging 24.0 pandas 2.2.3 Pillow 11.0.0 pip 24.1 PyArrow 18.0.0 pybind11 2.13 PyO3 N/A 0.22.2 N/A N/A PyWavelets 1.7.0 scikit-build-core 0.9.5 scikit-image scikit-learn 1.6.0 SciPy 1.15.0 setuptools 69.5.0 zstandard <ol> <li> <p>Windows isn't correctly handled yet in CMake 3.30.0, see cmake#26016 \u21a9</p> </li> </ol>"}]}